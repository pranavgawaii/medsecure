{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/8teen/Downloads/Devlopment/GitHub%20Repository/medsecurree/lib/db.ts"],"sourcesContent":["import { neon } from \"@neondatabase/serverless\"\n\n// Create a singleton instance of the SQL client\nlet sqlInstance: ReturnType<typeof neon> | null = null\nconst USE_MOCK_DATA = !process.env.NEON_POSTGRES_URL && !process.env.NEON_NEON_NEON_DATABASE_URL;\n\n/**\n * Gets or creates a Neon SQL client instance\n */\nexport function getSql() {\n  if (USE_MOCK_DATA) return null;\n\n  if (!sqlInstance) {\n    const databaseUrl = process.env.NEON_POSTGRES_URL || process.env.NEON_NEON_NEON_DATABASE_URL\n    if (!databaseUrl) {\n      console.warn(\"Database URL is not configured. Falling back to mock data.\")\n      return null;\n    }\n    sqlInstance = neon(databaseUrl)\n  }\n  return sqlInstance\n}\n\n// --- SHARED IN-MEMORY STATE (GLOBAL) ---\n// This ensures data persists across API calls and hot reloads in dev mode\nconst globalStore = global as unknown as {\n  mockVitals: Map<string, any[]>;\n  mockAlerts: any[];\n  mockPatients: any[];\n};\n\n// Initialize if not exists\nif (!globalStore.mockPatients) {\n  globalStore.mockPatients = [\n    { patient_id: \"PAT001\", name: \"John Doe\", age: 45, medical_condition: \"Cardiac Arrhythmia\", ambulance_id: \"AMB001\" },\n    { patient_id: \"PAT002\", name: \"Jane Smith\", age: 62, medical_condition: \"Hypertension\", ambulance_id: \"AMB002\" },\n    { patient_id: \"PAT003\", name: \"Robert Johnson\", age: 35, medical_condition: \"Allergic Reaction\", ambulance_id: \"AMB001\" },\n    { patient_id: \"PAT004\", name: \"Emily Davis\", age: 28, medical_condition: \"Asthma Attack\", ambulance_id: \"AMB002\" },\n  ];\n}\n\nif (!globalStore.mockVitals) {\n  globalStore.mockVitals = new Map();\n  // seed some initial vitals\n  globalStore.mockPatients.forEach(p => {\n    globalStore.mockVitals.set(p.patient_id, []);\n  });\n}\n\nif (!globalStore.mockAlerts) {\n  globalStore.mockAlerts = [];\n}\n\n// --- HELPER GENERATORS ---\nconst generateMockVital = (patientId: string) => ({\n  id: Math.floor(Math.random() * 10000),\n  patient_id: patientId,\n  ambulance_id: globalStore.mockPatients.find(p => p.patient_id === patientId)?.ambulance_id || \"AMB-UNK\",\n  heart_rate: 60 + Math.floor(Math.random() * 40),\n  spo2: 95 + Math.floor(Math.random() * 5),\n  systolic_bp: 110 + Math.floor(Math.random() * 30),\n  diastolic_bp: 70 + Math.floor(Math.random() * 20),\n  temperature: 36.5 + Math.random(),\n  status: \"Normal\",\n  recorded_at: new Date().toISOString(),\n  encrypted_data: \"mock-encrypted-string-\" + Math.random().toString(36).substring(7)\n});\n\nconst generateMockAlert = (patientId: string) => ({\n  id: Math.floor(Math.random() * 100000),\n  patient_id: patientId,\n  alert_type: \"Vital Sign Warning\",\n  alert_level: [\"Low\", \"Medium\", \"High\", \"Critical\"][Math.floor(Math.random() * 4)],\n  message: `Abnormal vitals detected for ${patientId}`,\n  is_acknowledged: false,\n  created_at: new Date().toISOString()\n});\n\n/**\n * Fetches current vital data for a patient\n */\nexport async function getLatestVitals(patientId: string) {\n  const sql = getSql()\n  if (!sql) {\n    const history = globalStore.mockVitals.get(patientId) || [];\n    return history.length > 0 ? history[0] : generateMockVital(patientId);\n  }\n  try {\n    const result: any = await sql`SELECT * FROM vitals WHERE patient_id = ${patientId} ORDER BY recorded_at DESC LIMIT 1`\n    return result[0] || null\n  } catch (e) {\n    console.error(\"DB Error:\", e);\n    const history = globalStore.mockVitals.get(patientId) || [];\n    return history.length > 0 ? history[0] : generateMockVital(patientId);\n  }\n}\n\n/**\n * Fetches all recent vitals for a patient\n */\nexport async function getRecentVitals(patientId: string, minutes = 60) {\n  const sql = getSql()\n  if (!sql) {\n    const history = globalStore.mockVitals.get(patientId) || [];\n    // Sort desc\n    const sorted = [...history].sort((a, b) => new Date(b.recorded_at).getTime() - new Date(a.recorded_at).getTime());\n    // Limit to recent 'minutes' (simulated by just taking last 50)\n    return sorted.slice(0, 50);\n  }\n  try {\n    const result = await sql`SELECT * FROM vitals \n       WHERE patient_id = ${patientId} \n       AND recorded_at > NOW() - INTERVAL '${minutes} minutes'\n       ORDER BY recorded_at ASC`\n    return result\n  } catch (e) {\n    const history = globalStore.mockVitals.get(patientId) || [];\n    return history.slice(0, 50);\n  }\n}\n\n/**\n * Stores vital data in the database (or memory)\n */\nexport async function storeVitals(vitalData: {\n  patientId: string\n  ambulanceId: string\n  heartRate: number\n  spo2: number\n  systolicBp: number\n  diastolicBp: number\n  temperature: number\n  status: string\n  encryptedData?: string\n}) {\n  const sql = getSql()\n  if (!sql) {\n    console.log(\"[Mock DB] Storing vitals to Memory:\", vitalData.patientId);\n\n    const newVital = {\n      id: Math.floor(Math.random() * 1000000),\n      patient_id: vitalData.patientId,\n      ambulance_id: vitalData.ambulanceId,\n      heart_rate: vitalData.heartRate,\n      spo2: vitalData.spo2,\n      systolic_bp: vitalData.systolicBp,\n      diastolic_bp: vitalData.diastolicBp,\n      temperature: vitalData.temperature,\n      status: vitalData.status,\n      recorded_at: new Date().toISOString(),\n      encrypted_data: vitalData.encryptedData || \"mock-encrypted\"\n    };\n\n    if (!globalStore.mockVitals.has(vitalData.patientId)) {\n      globalStore.mockVitals.set(vitalData.patientId, []);\n    }\n\n    // Unshift to add to beginning (Latest)\n    globalStore.mockVitals.get(vitalData.patientId)?.unshift(newVital);\n\n    // Keep size manageable\n    if ((globalStore.mockVitals.get(vitalData.patientId)?.length || 0) > 100) {\n      globalStore.mockVitals.get(vitalData.patientId)?.pop();\n    }\n\n    return newVital;\n  }\n  // SQL Implementation omitted for brevity in mock-only context, but would be here\n  return null;\n}\n\n/**\n * Creates an alert\n */\nexport async function createAlert(alertData: {\n  patientId: string\n  alertType: string\n  alertLevel: string\n  message: string\n}) {\n  const sql = getSql()\n  if (!sql) {\n    console.log(\"[Mock DB] Creating Alert in Memory:\", alertData);\n    const newAlert = {\n      id: Math.floor(Math.random() * 1000000),\n      patient_id: alertData.patientId,\n      alert_type: alertData.alertType,\n      alert_level: alertData.alertLevel,\n      message: alertData.message,\n      is_acknowledged: false,\n      created_at: new Date().toISOString()\n    };\n    globalStore.mockAlerts.unshift(newAlert);\n    return newAlert;\n  }\n  return null;\n}\n\n/**\n * Fetches all active (unacknowledged) alerts\n */\nexport async function getActiveAlerts() {\n  const sql = getSql()\n  if (!sql) {\n    return globalStore.mockAlerts.filter(a => !a.is_acknowledged);\n  }\n  return [];\n}\n\n/**\n * Fetches all alerts for a specific patient\n */\nexport async function getPatientAlerts(patientId: string) {\n  const sql = getSql()\n  if (!sql) {\n    return globalStore.mockAlerts.filter(a => a.patient_id === patientId);\n  }\n  return [];\n}\n\n/**\n * Acknowledges an alert\n */\nexport async function acknowledgeAlert(alertId: number, acknowledgedBy: string) {\n  const sql = getSql()\n  if (!sql) {\n    const alert = globalStore.mockAlerts.find(a => a.id === alertId);\n    if (alert) {\n      alert.is_acknowledged = true;\n      alert.acknowledged_by = acknowledgedBy;\n      alert.acknowledged_at = new Date().toISOString();\n      return alert;\n    }\n    return null;\n  }\n  return null;\n}\n\n/**\n * Fetches patient information\n */\nexport async function getPatient(patientId: string) {\n  return globalStore.mockPatients.find(p => p.patient_id === patientId) || globalStore.mockPatients[0];\n}\n\n/**\n * Gets all patients\n */\nexport async function getAllPatients() {\n  return globalStore.mockPatients;\n}\n\n/**\n * Fetches all patients with their latest vitals\n */\nexport async function getAllPatientsWithVitals() {\n  const sql = getSql()\n  if (!sql) {\n    return globalStore.mockPatients.map(p => {\n      const history = globalStore.mockVitals.get(p.patient_id) || [];\n      const v = history.length > 0 ? history[0] : null;\n\n      if (!v) {\n        // Return basic info even if no vitals yet\n        return { ...p, vital_id: null, heart_rate: null, status: \"No Data\" };\n      }\n\n      return {\n        ...p,\n        vital_id: v.id,\n        heart_rate: v.heart_rate,\n        spo2: v.spo2,\n        systolic_bp: v.systolic_bp,\n        diastolic_bp: v.diastolic_bp,\n        temperature: v.temperature,\n        status: v.status,\n        recorded_at: v.recorded_at,\n        encrypted_data: v.encrypted_data,\n        ambulance_id: v.ambulance_id\n      };\n    });\n  }\n  return [];\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 317, "column": 0}, "map": {"version":3,"sources":["file:///Users/8teen/Downloads/Devlopment/GitHub%20Repository/medsecurree/app/api/alerts/active/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\nimport { getActiveAlerts } from \"@/lib/db\"\n\n/**\n * Retrieves all active (unacknowledged) alerts\n * GET /api/alerts/active\n */\nexport async function GET() {\n  try {\n    const alerts = await getActiveAlerts()\n\n    return NextResponse.json({\n      success: true,\n      alerts: alerts.map((alert: any) => ({\n        id: alert.id,\n        patientId: alert.patient_id,\n        alertType: alert.alert_type,\n        alertLevel: alert.alert_level,\n        message: alert.message,\n        isAcknowledged: alert.is_acknowledged,\n        createdAt: alert.created_at,\n      })),\n      count: alerts.length,\n    })\n  } catch (error) {\n    console.error(\"Error retrieving alerts:\", error)\n    return NextResponse.json({ error: \"Failed to retrieve alerts\" }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAMO,eAAe;IACpB,IAAI;QACF,MAAM,SAAS,MAAM,IAAA,8HAAe;QAEpC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,QAAQ,OAAO,GAAG,CAAC,CAAC,QAAe,CAAC;oBAClC,IAAI,MAAM,EAAE;oBACZ,WAAW,MAAM,UAAU;oBAC3B,WAAW,MAAM,UAAU;oBAC3B,YAAY,MAAM,WAAW;oBAC7B,SAAS,MAAM,OAAO;oBACtB,gBAAgB,MAAM,eAAe;oBACrC,WAAW,MAAM,UAAU;gBAC7B,CAAC;YACD,OAAO,OAAO,MAAM;QACtB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA4B,GAAG;YAAE,QAAQ;QAAI;IACjF;AACF","debugId":null}}]
}